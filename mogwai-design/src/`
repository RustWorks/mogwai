use std::any::Any;
use std::cell::RefCell;


#[derive(Clone)]
struct Dynamic<T: Any + Clone> {
  current: T,
}


impl<T> Dynamic<T>
where
  T: Any + Clone
{
  /// Create a new dynamic with the given value.
  pub fn new(t:T) -> Dynamic<T> {
    Dynamic {
      current: t,
      subs: Vec<Fn(&T)>
    }
  }

  /// Get a reference to the dynamic's current value.
  pub fn value(&self) -> &T {
    &self.current
  }

  /// Update the dynamic's current value, triggering an update to anything
  /// dependent upon the dynamic.
  pub fn update(&mut self, t:T) {
    self.current = t;
  }

  /// Convert the inner value of the dynamic.
  pub fn map<Q: Any + Clone, F: Fn(T) -> Q>(self, f:F) -> Dynamic<Q> {
    Dynamic::new(f(self.value().clone()))
  }

  /// Subscribe to the dynamic with a function.
  /// This triggers the function whenever Dynamic::update is called.
  pub fn subscribe<F: Fn(&T)>(&mut self, f:F) {

  }
}


#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn can_sub_and_update() {
    let mut dynamic:Dynamic<String> =
      Dynamic::new("Hello".into());

    let other:RefCell<String> =
      RefCell::new(
        dynamic
          .value()
          .clone()
      );

    let trigger = |s:&String| {
      println!("Got {:?}", s);
      let mut inner =
        other
        .borrow_mut();
      *inner = s.clone();
    };

    dynamic
      .subscribe(trigger);

    dynamic
      .update("Goodbye".into());

    assert_eq!(*other.borrow(), "Goodbye".to_string());
  }
}
